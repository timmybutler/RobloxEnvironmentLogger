Lune
A standalone Luau runtime.

Write and run programs, similar to runtimes for other languages such as Node, Deno, Bun, or Luvit for vanilla Lua.

Lune provides fully asynchronous APIs wherever possible, and is built in Rust ü¶Ä for speed, safety and correctness.

Features
üåô Strictly minimal but powerful interface that is easy to read and remember, just like Luau itself
üß∞ Fully featured APIs for the filesystem, networking, stdio, all included in the small (~5mb zipped) executable
üìö World-class documentation, on the web or directly in your editor, no network connection necessary
üè° Familiar runtime environment for Roblox developers, with an included 1-to-1 task scheduler port
‚úèÔ∏è Optional standard library for manipulating Roblox place & model files, and their instances
Non-goals
Making programs short and terse - proper autocomplete / intellisense make using Lune just as quick, and readability is important
Running full Roblox games outside of Roblox - there is some compatibility, but Lune is meant for different purposes
Where do I start?
Head over to the Installation page to get started using Lune!

Installation
The preferred way of installing Lune is using Rokit, a toolchain manager for Roblox projects. Rokit can manage your installed version of Lune and other ecosystem tools, and allows you to easily upgrade to newer versions as they become available.

Installing Rokit
Follow the installation instructions on the Rokit page.

Installing Lune
Navigate to your project directory using your terminal, and run the following command:

Terminal
rokit add lune

Upgrading Lune
When a new version of Lune becomes available, Rokit makes it easy to upgrade. Navigate to your project directory using your terminal again, and run the following command:

Terminal
rokit update lune

If you prefer to install Lune globally and have it accessible on your entire system, instead of only in a specific project, you can do this with Rokit as well. Just add the --global option to the end of the commands above.

Other Installation Options
Using GitHub Releases
Community-maintained
Using crates.io
Next Steps
Congratulations! You‚Äôve installed Lune and are now ready to write your first script.

A great place to continue reading is the Lune Book, which is also part of the official Lune documentation, and will give you a guided and comprehensive introduction to Lune.

Or, if you want to dive right into specific resources, check out the API reference in the sidebar.

Command-Line Usage
Running Scripts
Once you‚Äôve written a script file, for example script-name.luau, you can run it as follows:

Terminal
lune run script-name

Lune will look for the file script-name.luau[1] in a few locations:

The current directory
The folder lune in the current directory, if it exists
The folder .lune in the current directory, if it exists
The folder lune in your home directory, if it exists
The folder .lune in your home directory, if it exists
Listing Scripts
Terminal
lune list

This command lists all scripts found in lune or .lune directories, including any top-level description comments. Lune description comments are written at the top of a file and start with a Lua-style comment arrow (-->).

Advanced Usage
Terminal
lune run -

This runs a script passed to Lune using stdin, which is useful for running scripts piped from external sources. Here‚Äôs an example:

Terminal
echo "print 'Hello, terminal!'" | lune run -

[1] Lune also supports files with the .lua extension, but using the .luau extension is highly recommended. Additionally, if you don‚Äôt want Lune to look in subdirectories or try to find files with .lua / .luau extensions at all, you can provide an absolute file path. This will disable all file path parsing and checks, and just run the file directly.

Editor Setup
Lune prioritizes developer experience, providing type definitions and documentation for many editors and tools without any additional downloads. This guide will help you set up your editor environment.

Luau Language Server
The open source Luau Language Server, also known as luau-lsp, is currently the main language server providing editor support for Luau. It supports a wide range of editors.

Once you‚Äôve installed both the language server and Lune, you can run the following command to generate type definition files and create or update a standardized .luaurc configuration file:

Terminal
lune setup

This should be all you need to get up and running. You may, however, need to restart your editor for the changes to take effect.

Security
When running Lune scripts, it‚Äôs important to know that any scripts you execute have full access to your device - this means access to your files, programs, and more. It is generally good to be cautious when running scripts from sources you don‚Äôt trust.

Here are some ways to run untrusted scripts more safely:

Running Lune scripts in a custom sandboxed environment
Using a containerized environment such as Docker
Using a virtual machine
Sandboxing
Lune provides a basic but functional sandboxing example. We‚Äôll show you how to use it here, but for production use and proper security, using a container or virtual machine is highly recommended.

Copy the sandbox module and save it as sandbox.luau.

Place the untrusted script you want to run next to the sandbox.luau file.

Terminal
lune run sandbox.luau script.luau -- [ARGUMENTS_HERE]

Replace script.luau and [ARGUMENTS_HERE] with the path to your script and any arguments you want to pass to it.

As the script runs, any attempts to access potentially dangerous modules will require your approval before continuing. Any method calls within approved modules will be logged.

The output from the sandbox script and the script being run will be clearly separated, so you can see what‚Äôs happening.

Hello, Lune!
Welcome to The Lune Book! Now that you have Lune installed, you‚Äôre ready to start writing scripts and exploring what makes Lune special.

If you‚Äôve written Lua or Luau scripts before, you‚Äôll feel right at home with the examples in this book. Even if you haven‚Äôt, don‚Äôt worry - this guide will take you through everything step by step.

The chapters in this book are organized to build on each other, starting with the basics, and gradually introducing more powerful features. Here‚Äôs a quick overview:

Hello, Lune! (you are here)
The Standard Library
Input & Output
Arguments
Networking
Working with Files
Modules
Spawning Programs
Task Scheduler
By the end of this book, you‚Äôll understand how to use Lune for everything from simple automation scripts to complex networking applications. Let‚Äôs get started!

The Standard Library
Lune has a comprehensive standard library that gives your scripts powerful capabilities. These libraries let you do everything from reading files, to making web requests, to running other programs.

Here are some of the most commonly used libraries:

fs - Work with files and directories
net - Make HTTP requests and create servers
process - Run external programs and access system information
stdio - Get input from users and display output
task - Schedule and manage concurrent tasks
Importing Libraries
Unlike Luau‚Äôs globals like math or table, Lune‚Äôs libraries need to be imported before you can use them. You do this with a special require statement:

local fs = require("@lune/fs")
local net = require("@lune/net")
local process = require("@lune/process")

The @lune/ prefix tells Lune that you want to use one of its standard libraries rather than looking for a file in your project.

Throughout the rest of this book, we‚Äôll explore these libraries in detail and see how they work together to make Lune scripts powerful and flexible.

Input & Output
Let‚Äôs start exploring Lune‚Äôs capabilities with the stdio library, which handles standard input and output. This is one of the most useful libraries for creating interactive scripts.

Getting User Input
The stdio library makes it easy to interact with users. Let‚Äôs create our first interactive script called hello.luau:

hello.luau
local stdio = require("@lune/stdio")

local name = stdio.prompt("text", "What's your name?")

print(`Hello, {name}!`)

Save this file in your current directory, then run it using the Lune CLI:

Terminal
lune run hello

When you run this script, it will wait for you to type your name and press Enter, then greet you!

Different Types of Prompts
The stdio library can prompt for more than just text. Let‚Äôs expand our script to ask a yes/no question:

hello.luau
local stdio = require("@lune/stdio")

local name = stdio.prompt("text", "What's your name?")
print(`Hello, {name}!`)

local confirmed = stdio.prompt("confirm", "Is that really your name?")
if confirmed then
  print(`Nice to meet you, {name}!`)
  print("Have a great day!")
else
  print("Hmm, well whoever you are, welcome!")
end

The confirm prompt type shows a yes/no question and returns true or false based on the user‚Äôs choice.

These two prompt types - text and confirm - will cover most of your interactive script needs. There are more advanced options available in the stdio API reference when you need them.

Extra: Number Guessing Game
What‚Äôs Next?
Now that you know how to get input from users, let‚Äôs learn about handling input that comes from the command line when someone runs your script. This is covered in the next chapter on Arguments.

Arguments
When you run a Lune script, you can pass information to it directly from the command line. These are called arguments, and they‚Äôre incredibly useful for making your scripts flexible and reusable.

Passing Arguments
Passing arguments when running a script is dead simple. Here‚Äôs how:

Terminal
lune run script-name arg1 arg2 "argument three"

Using Arguments
Your script can then access these arguments through the process standard library:

local process = require("@lune/process")

print(process.args)
--> { "arg1", "arg2", "argument three" }

The arguments will always be an array (table) of strings, in the same order you provided them.

A Practical Example
Let‚Äôs create a script that greets someone by name:

greet.luau
local process = require("@lune/process")

if #process.args == 0 then
  print("Usage: lune run greet <name>")
  print("Example: lune run greet Alice")
else
  local name = process.args[1]
  print(`Hello, {name}! Welcome to Lune.`)
end

Now you can run it with different names:

Terminal
lune run greet Alice
--> Hello, Alice! Welcome to Lune.

lune run greet "John Doe"
--> Hello, John Doe! Welcome to Lune.

Combining Arguments with User Input
Here‚Äôs a clever pattern - use arguments when provided, but fall back to prompting the user if they‚Äôre missing:

smart-greet.luau
local process = require("@lune/process")
local stdio = require("@lune/stdio")

local name
if #process.args > 0 then
  name = process.args[1]
else
  name = stdio.prompt("text", "What's your name?")
end

print(`Hello, {name}!`)

This script works both ways - with arguments or interactively!

What‚Äôs Next?
Now that you can handle user input and arguments, let‚Äôs explore one of Lune‚Äôs most powerful features - the standard library for networking. Head over to Networking to learn more.

Networking
Now we‚Äôre getting to the really fun stuff! The net library lets your scripts talk to the internet - whether that‚Äôs fetching data from websites, calling APIs, or even creating your own web servers.

Making Web Requests
Let‚Äôs start with something simple - fetching a web page:

simple-request.luau
local net = require("@lune/net")

local response = net.request("https://www.example.com")

if response.ok then
  print(`Success! Got {#response.body} bytes`)
  print(`Status: {response.statusCode} {response.statusMessage}`)
else
  print(`Request failed: {response.statusCode}`)
end

When you make a request, you get back a response object with everything you need - the status code, headers, body content, and an ok field that tells you if things went well.

Working with APIs
Most modern web services use APIs that speak JSON. Here‚Äôs how you can work with them:

github-api.luau
local net = require("@lune/net")
local serde = require("@lune/serde")

-- Let's search GitHub for popular Luau projects
local response = net.request({
  url = "https://api.github.com/search/repositories",
  query = {
    q = "language:luau",
    sort = "stars",
    per_page = "3"
  }
})

if response.ok then
  local results = serde.decode("json", response.body)
  print(`Found {results.total_count} Luau repositories!\n`)

  for _, repo in results.items do
    print(`‚≠ê {repo.stargazers_count} - {repo.full_name}`)
    print(`   {repo.description}\n`)
  end
end

When you need to send data to an API, you‚Äôll typically use methods other than GET, such as POST or PATCH:

posting-stuff.luau
local response = net.request({
  url = "https://api.example.com/data",
  method = "POST",
  headers = { ["Content-Type"] = "application/json" },
  body = serde.encode("json", {
    name = "My Lune Script",
    version = "1.0.0"
  })
})

The serde library handles all the JSON encoding and decoding for you, so you can work with regular Lua tables and other datatypes.

Running a Web Server
Sometimes you don‚Äôt want to make requests - you want to receive them. Creating a web server with Lune is surprisingly easy:

my-server.luau
local net = require("@lune/net")

local visitCount = 0

net.serve(8080, function(request)
  visitCount += 1

  print(`[{request.method}] {request.path} - Visit #{visitCount}`)

  if request.path == "/" then
    return {
      status = 200,
      headers = { ["Content-Type"] = "text/html" },
      body = `<h1>Hello, visitor #{visitCount}!</h1>
             <p>Try visiting <a href="/api">/api</a></p>`
    }
  elseif request.path == "/api" then
    return {
      status = 200,
      headers = { ["Content-Type"] = "text/plain" },
      body = `You are visitor number {visitCount}`
    }
  else
    return { status = 404, body = "Page not found" }
  end
end)

print("Server running at http://localhost:8080")
print("Press Ctrl+C to stop")

Your server can handle different routes, check request methods and headers, parse request bodies - everything you need for building real web applications.

Beyond HTTP
The net library has even more tricks up its sleeve. It can handle WebSockets for real-time communication, raw TCP connections for custom protocols, and more.

WebSockets
WebSockets are perfect when you need real-time, two-way communication. Lune makes these very easy to use as well:

websocket-client.luau
local net = require("@lune/net")

-- Connect to a WebSocket echo server
local socket = net.socket("wss://echo.websocket.org")

socket:send("Hello from Lune!")

-- Wait for the echo
local reply = socket:next()
print(`Server echoed: {reply}`)

socket:close()

Extra: WebSocket Echo Server
Advanced: TCP Connections
What‚Äôs Next?
With all this network power at your fingertips, you‚Äôll probably want to save some of that data you‚Äôre fetching. Let‚Äôs explore how to work with files and directories in Working with Files.

Working with Files
The fs library lets you work with files and directories in Lune. You can read, write, copy, and move files around with no extra boilerplate.

Example File Tree
Let‚Äôs use this directory and file structure for our examples:

files.luau
dirs.luau
hello-world.json
Directoryfiles
coolstuff.toml
super.secret.txt
Show file contents
Files
Reading and writing files using the fs library is simple and only works with strings:

files.luau
local fs = require("@lune/fs")

-- Print out the contents of all of the files
print(fs.readFile("hello-world.json"))
print(fs.readFile("files/coolstuff.toml"))
print(fs.readFile("files/super.secret.txt"))

-- Create a new file in our "files" directory
fs.writeFile("files/My Favorite Numbers.txt", "2 4 6 8 0")

-- Write to one of our files, overwriting any previous contents
fs.writeFile("files/super.secret.txt", "Super secret message")

-- Remove the new file we created in our "files" directory
fs.removeFile("files/My Favorite Numbers.txt")

Note that the filesystem library works with raw strings for file contents and doesn‚Äôt differentiate between binary, UTF-8, or other encodings. It‚Äôs up to you to know how your files are structured and handle them appropriately.

Directories
Reading and creating directories has a similar API, but with slightly different parameters and return values:

dirs.luau
local fs = require("@lune/fs")

-- Print out the entries found in our directory
-- The "." here means the current directory
print("Contents of current directory:")
for _, entry in fs.readDir(".") do
  if fs.isDir(entry) then
    print(`üìÅ {entry}`)
  elseif fs.isFile(entry) then
    print(`üìÑ {entry}`)
  end
end

-- Create a new directory next to the above entries
fs.writeDir("myCoolDir")

-- Create a new directory in our "files" directory
fs.writeDir("files/myCoolSecondDir")

-- Remove the entire files directory
fs.removeDir("files")

In the above example:

fs.readDir returns a table (array) of strings with file and directory names
fs.writeDir takes only the directory name (path) to create a directory
fs.removeDir removes the directory and everything inside it - use with caution!
Resulting File Tree
This is what our directory structure would look like after running the above examples:

files.luau
dirs.luau
hello-world.json
DirectorymyCoolDir/
What‚Äôs Next?
Now that you know how to work with files and directories, let‚Äôs learn about organizing your code with Modules.

Modules
At this point you know how the most important standard libraries in Lune work and how to use them - and your code may be getting longer and more difficult to read.

Modularizing your code and splitting it across several files in Lune is different from other versions of Lua, and more similar to how things work in other languages such as JavaScript.

File Structure
Let‚Äôs start with a typical module setup that we‚Äôll use throughout this chapter:

main.luau
sibling.luau
Directorydirectory
init.luau
child.luau
This structure shows the two main patterns you‚Äôll use - individual module files (sibling.luau) and directory modules (modules/ with its init.luau). The contents of these files are not very important for this article, but here is an example for the sake of completeness:

Main File
Sibling File
Directory Module (init)
Child Module
main.luau
local sibling = require("./sibling")
local directory = require("./directory")

print(sibling.Hello) --> World

print(directory.Child.Foo) --> Bar
print(directory.Child.Fizz) --> Buzz

print(directory.Sibling.Hello) --> World

How Does It Work?
Looking at our main file, you‚Äôll notice the require paths always start with ./ or ../. This means ‚Äúrelative to the current file‚Äù, the same way it does in your terminal. When main.luau requires "./sibling", Lune looks for sibling.luau in the same directory as main.

The interesting part is require("./modules"). Lune sees this is a directory and automatically looks for modules/init.luau. Inside that init file, we use two different types of require statements:

The statement require("@self/child") uses the special @self alias. Since init files represent their parent directory, @self here means - inside the ‚Äúmodules‚Äù directory. Without it, require("./child") would look for child.luau next to the ‚Äúmodules‚Äù directory, not inside it.

Note

Q: Wait, the main script requires a directory?
A: Exactly! When you require a directory, Lune looks for init.luau inside it. This pattern lets you create modules using directories - and these are extremely useful for organizing your code as a reusable package, for example.

Coming from Other Languages
If you‚Äôre arriving at Lune with experience in other runtimes & languages, these comparisons may help you get oriented. If you want to get right into the nitty-gritty details, feel free to skip this section completely.

Lua 5.x
JavaScript / TypeScript
Python
Rust
Traditional Lua Structure:

main.lua
mylib.lua
Directoryutils/
init.lua
helper.lua
main.lua
-- Lua 5.x - requires are relative to the working directory
-- You need to configure package.path:
package.path = package.path .. ";./utils/?.lua"

local mylib = require("mylib")         -- Only works if CWD is correct
local utils = require("utils")         -- Needs package.path setup
local helper = require("utils.helper") -- Uses dots, not slashes

main.luau
-- Lune - requires are relative to the file
local mylib = require("./mylib")         -- Always works
local utils = require("./utils")         -- No path config needed
local helper = require("./utils/helper") -- Uses slashes like paths

The main difference here is that, in traditional Lua, requires depend on where you run the script from. In Lune, requires are relative to the file containing them, making your code portable and predictable.

Module Caching
Every module you require gets cached on the first call to the require function. This means that it is safe to store state within modules, and expose it using public functions:

counter.luau
local count = 0
return {
    increment = function()
        count += 1
        return count
    end
}

main.luau
local counter1 = require("./counter")
local counter2 = require("./counter")

print(counter1.increment()) --> 1
print(counter2.increment()) --> 2 (same table & function pointer!)
print(counter1 == counter2)  --> true

This caching behavior is usually what you want - it prevents duplicate initialization and lets modules maintain internal state. Just remember that if you need separate instances of a class or something similar, you‚Äôll need to return a function that creates its own, separate state.

Extra: Async Caching
Path Resolution
Lune keeps path resolution simple and predictable. Paths are case-sensitive on all platforms (even Windows) and always use forward slashes. When you require "./myModule", Lune checks for:

myModule.luau (preferred extension)
myModule.lua (for compatibility)
myModule/init.luau (directory module)
myModule/init.lua (directory module, compatibility)
The search behavior is also consistent across all platforms.

Configuring Aliases Using .luaurc
Lune supports standardized Luau configuration files that can define aliases and other settings for your project. To use aliases, you will need to create a JSON-like configuration file named .luaurc inside of a directory, as such:

.luaurc
{
  "aliases": {
    "utils": "./src/utilities",
    "config": "./configuration"
  }
}

With these aliases defined, you can use them anywhere in your project, using the @ prefix:

script.luau
-- Instead of long relative paths ...
local config = require("../../../configuration/settings")
local helper = require("../../src/utilities/helper")

-- ...you can use aliases!
local config = require("@config/settings")
local helper = require("@utils/helper")

It is also possible to create multiple .luaurc configuration files in your project. When Lune looks for a .luaurc file, it searches from your script‚Äôs directory up through parent directories. This means you can have project-wide configuration at the root, and override specific settings in subdirectories if necessary.

Note

Note: The @lune/ standard libraries like @lune/fs and @lune/net are special - it is not possible to override them using your own custom aliases.

What‚Äôs Next?
You now have all the tools to organize your Lune scripts into clean, reusable modules. You can split code into files, create module hierarchies with directories, and you understand how Lune‚Äôs caching mechanism and path resolution work.

But, what happens when you need functionality that Lune doesn‚Äôt provide? Sometimes the best solution isn‚Äôt to rewrite something in Luau - it‚Äôs to use existing tools on your system. Let‚Äôs extend Lune‚Äôs capabilities by Spawning Programs next.

Spawning Processes
Whenever Lune doesn‚Äôt have the API you need as part of its standard libraries, or when you want to use a program that already exists, but interact with it from within Lune, you can spawn a subprocess using process.exec.

Example
This example calls out to the native ‚Äúping‚Äù program found on many operating systems, and parses its output into something more usable.

This may look a bit intimidating with all the pattern matching symbols, but it‚Äôs just parsing the line that says "min/avg/max/stddev = W/X/Y/Z ms" from ping‚Äôs output:

ping-example.luau
local process = require("@lune/process")

print("Sending 4 pings to google.com...")

local result = process.exec("ping", {
  "google.com",
  "-c", "4",
})

if result.ok then
  assert(#result.stdout > 0, "Result output was empty")
  local min, avg, max, stddev = string.match(
    result.stdout,
    "min/avg/max/stddev = ([%d%.]+)/([%d%.]+)/([%d%.]+)/([%d%.]+) ms"
  )
  print(string.format("Minimum ping time: %.3fms", tonumber(min)))
  print(string.format("Maximum ping time: %.3fms", tonumber(max)))
  print(string.format("Average ping time: %.3fms", tonumber(avg)))
  print(string.format("Standard deviation: %.3fms", tonumber(stddev)))
else
  print("Failed to send ping to google.com")
  print(result.stderr)
  process.exit(result.code)
end

Note that if the subprocess returns a non-zero exit code (meaning it errored and ok was set to false), we propagate that exit code using process.exit. This ensures that if our subprocess fails, our script fails too, letting the user know something went wrong.

The Result Table
When you call process.exec, you get back a table with these fields:

ok - true if the exit code was 0 (success)
code - the actual exit code
stdout - what the program printed to standard output
stderr - what the program printed to standard error
This should give you everything you need to work with external programs the same way you would when using your terminal - all the text you see outputted when using your terminal, for example, is always part of either stdout or stderr.

Generally, program output will be in stdout, and error messages, warnings, and other miscellaneous information will be in stderr.

Common Use Cases
Beyond the ping example, here are some other ways you might use process.exec:

-- Run git commands
local gitStatus = process.exec("git", { "status", "--short" })

-- Compress files
local zipResult = process.exec("zip", { "-r", "archive.zip", "dir/" })

-- Manipulate images
local result = process.exec("convert", { "input.png", "-resize", "800x600", "output.jpg" })

Extra: Real-time Processing
What‚Äôs Next?
You can now extend Lune‚Äôs capabilities by running any program on your system. This opens up endless possibilities - from using git in your scripts to leveraging specialized tools for tasks Lune doesn‚Äôt handle natively.

But what if you need to run multiple operations at once? Or schedule work to happen later? Let‚Äôs explore Lune‚Äôs powerful concurrency features in our last chapter - The Task Scheduler.

The Task Scheduler
Lune is built around a task scheduler, which can let you run things at fixed intervals, ensure some work happens after everything else is already done, and more.

The task scheduler is the backbone of Lune, and lets you handle structured concurrency. It is implemented using lightweight Lua threads / coroutines, and has strong ordering guarantees.

Ordering
The main purpose of the task scheduler is to ensure consistent ordering, and to let you prioritize work on three different levels by using the task standard library:

Immediate: Tasks that should run immediately can be spawned using task.spawn.
Deferred: Tasks that should run after all immediate tasks have finished can be spawned using task.defer.
Delayed: Tasks that should run after a certain amount of time has passed can be spawned using task.delay.
Advanced: Runtime-Controlled Threads & Prioritization
Example Usage
Spawning Tasks & Waiting
This example script will run several tasks concurrently, in lightweight Lua threads, also known as coroutines:

basic-tasks.luau
local task = require("@lune/task")

print("Hello, scheduler!")

task.spawn(function()
  print("Spawned a task that will run instantly but not block")
  task.wait(2)
  print("The instant task resumed again after 2 seconds")
end)

print("Spawning a delayed task that will run after 5 seconds")

task.delay(5, function()
  print("Waking up from my deep slumber...")
  task.wait(1)
  print("Hello again!")
  task.wait(1)
  print("Goodbye again! üåô")
end)

Deferring Work
This example script runs a bit of work after all other threads have finished their work or are yielding waiting for some other result:

deferred-tasks.luau
local task = require("@lune/task")

task.defer(function()
  print("All the scheduled work has finished, let's do some more!")
  local a = 0
  for _ = 1, 100000 do
    local b = a + 1
  end
  print("Phew, that was tough.")
end)

print("Working...")
local s = ""
for _ = 1, 5000 do
  s ..= ""
end
print("Done!")

Advanced Usage & Async
Spawning tasks like this can be very useful together with asynchronous APIs from other standard libraries, such as net.request:

async-tasks.luau
local net = require("@lune/net")
local task = require("@lune/task")

local completed = false
task.spawn(function()
  while not completed do
    print("Waiting for response...")
    task.wait() -- Wait the minimum amount possible
  end
  print("No longer waiting!")
end)

print("Sending request")
net.request("https://google.com")
print("Got response")

completed = true

Bonus
Conclusion
Congratulations! You‚Äôve completed The Lune Book and now have all the tools you need to build powerful scripts with Lune.

You‚Äôve learned how to work with files, make network requests, handle user input, organize code into modules, spawn external processes, and how to wrangle the task scheduler. More importantly, you‚Äôve seen how these pieces work together to create scripts that are both simple to write and capable of handling complex real-world problems.

The API reference in the sidebar contains detailed documentation for all of Lune‚Äôs capabilities, and the community is always ready to help if you get stuck.

Now go build! üöÄ

The Roblox Library
Lune has a powerful standard library and set of APIs for manipulating Roblox place files and model files. It contains APIs for reading & writing files, and gives you instances to use, just as if you were scripting inside of the Roblox engine, albeit with a more limited API.

For examples on how to write Roblox-specific Lune scripts, check out the Examples page.
For a guide on how to migrate to Lune from Remodel, check out the Migrating from Remodel page.
For a list of the currently implemented Roblox APIs, check out the API Status page.

Example Scripts
These are a few short examples of things you can do using the roblox standard library.

Make all parts anchored in a place file
local fs = require("@lune/fs")
local roblox = require("@lune/roblox")

-- Read the place file called myPlaceFile.rbxl into a DataModel variable called "game"
-- This works exactly the same as in Roblox, except "game" does not exist by default.
-- To access "game" you have to load it from a file!
local file = fs.readFile("myPlaceFile.rbxl")
local game = roblox.deserializePlace(file)
local workspace = game:GetService("Workspace")

-- Make all of the parts in the workspace anchored
for _, descendant in workspace:GetDescendants() do
  if descendant:IsA("BasePart") then
    descendant.Anchored = true
  end
end

-- Save the DataModel (game) back to the file that we read it from
file = roblox.serializePlace(game)
fs.writeFile("myPlaceFile.rbxl", file)

Save instances in a place as individual model files
local fs = require("@lune/fs")
local roblox = require("@lune/roblox")

-- Here we load a file just like in the first example
local file = fs.readFile("myPlaceFile.rbxl")
local game = roblox.deserializePlace(file)
local workspace = game:GetService("Workspace")

-- Make sure a directory exists to save our models in
fs.writeDir("models")

-- Then we save all of our instances in Workspace as model files, in our new directory
-- Note that a model file can actually contain several instances at once, so we pass a table here
for _, child in workspace:GetChildren() do
  file = roblox.serializeModel({ child })
  fs.writeFile("models/" .. child.Name, file)
end

Make a new place from scratch
local fs = require("@lune/fs")
local roblox = require("@lune/roblox")
local Instance = roblox.Instance

-- You can even create a new DataModel using Instance.new, which is not normally possible in Roblox
-- This is normal - most instances that are not normally accessible in Roblox can be manipulated using Lune!
local game = Instance.new("DataModel")
local workspace = game:GetService("Workspace")

-- Here we just make a bunch of models with parts in them for demonstration purposes
for i = 1, 50 do
  local model = Instance.new("Model")
  model.Name = "Model #" .. tostring(i)
  model.Parent = workspace
  for j = 1, 4 do
    local part = Instance.new("Part")
    part.Name = "Part #" .. tostring(j)
    part.Parent = model
  end
end

-- As always, we have to save the DataModel (game) to a file when we're done
local file = roblox.serializePlace(game)
fs.writeFile("myPlaceWithLotsOfModels.rbxl", file)

Migrating from Remodel
If you have used Remodel before to manipulate place and/or model files, this migration guide will help you get started with accomplishing the same tasks in Lune.

Drop-in Compatibility
This guide provides a module which translates all of the relevant Lune APIs to their Remodel equivalents. For more details or manual migration steps, check out Differences Between Lune & Remodel below.

Copy the remodel module and place it in a file named remodel.luau.

This module is quite large, but you will not need to read through it unless you want to know about the internal details of how Remodel used to work.

Next, create another script next to your remodel.luau. We will be naming it example.luau, but you can name it whatever you want. This example code is from one of the legacy Remodel-native example scripts, with only the top line added:

remodel.luau
local remodel = require("./remodel")

-- One use for Remodel is to move the terrain of one place into another place.
local inputGame = remodel.readPlaceFile("input-place.rbxlx")
local outputGame = remodel.readPlaceFile("output-place.rbxlx")

-- This isn't possible inside Roblox, but works just fine in Remodel!
outputGame.Workspace.Terrain:Destroy()
inputGame.Workspace.Terrain.Parent = outputGame.Workspace

remodel.writePlaceFile("output-place-updated.rbxlx", outputGame)

Finally, run the script you‚Äôve created by providing the script name to Lune, in our case example, without the luau file extension. Everything should work the same way it did when running natively in Remodel, now running in Lune üöÄ

Terminal
lune run example

Differences Between Lune & Remodel
Most APIs previously found in Remodel have direct equivalents in Lune, below are some direct links to APIs that are equivalent or very similar.

Places & Models
Files & Directories
JSON
Since Lune is meant to be a general-purpose Luau runtime, there are also some more general differences, and Lune takes a different approach from Remodel in certain areas:

Lune runs Luau instead of Lua 5.3.
APIs are more loosely coupled, meaning that a task may require more steps using Lune. This also means that Lune is more flexible and supports more use cases.
Standard libraries are not accessible from global variables, you have to explicitly import them using require("@lune/library-name").
Arguments given to scripts are not available in ..., you have to use process.args instead.
Lune generally supports all of the Roblox datatypes that are gettable/settable on instance properties. For a full list of available datatypes, check out the API Status page.
There may be more differences than are listed here, and the Lune-specific guides and examples may provide more info, but this should be all you need to know to migrate from Remodel. Good luck!

API Status
This is a page indicating the current implementation status for instance methods and datatypes in the roblox library.

If an API on a class is not listed here it may not be within the scope for Lune and may not be implemented in the future.
However, if a recently added datatype is missing, and it can be used as an instance property, it is likely that it will be implemented.

Classes
Instance
Currently implemented APIs:

new - note that this does not include the second parent argument
AddTag
Clone
Destroy
ClearAllChildren
FindFirstAncestor
FindFirstAncestorOfClass
FindFirstAncestorWhichIsA
FindFirstChild
FindFirstChildOfClass
FindFirstChildWhichIsA
GetAttribute
GetAttributes
GetChildren
GetDescendants
GetFullName
GetTags
HasTag
IsA
IsAncestorOf
IsDescendantOf
RemoveTag
SetAttribute
DataModel
Currently implemented APIs:

GetService
FindService
Datatypes
Currently implemented datatypes:

Axes
BrickColor
CFrame
Color3
ColorSequence
ColorSequenceKeypoint
Enum
Faces
Font
NumberRange
NumberSequence
NumberSequenceKeypoint
PhysicalProperties
Ray
Rect
Region3
Region3int16
UDim
UDim2
Vector2
Vector2int16
Vector3
Vector3int16
Note that these datatypes are kept as up-to-date as possible, but recently added members & methods may be missing.

DateTime
Built-in library for date & time

Example usage
local DateTime = require("@lune/datetime")

-- Creates a DateTime for the current exact moment in time
local now = DateTime.now()

-- Formats the current moment in time as an RFC 3339 string
print(now:toRfc3339())

-- Formats the current moment in time as an RFC 2822 string
print(now:toRfc2822())

-- Formats the current moment in time, using the local
-- time, the French locale, and the specified time string
print(now:formatLocalTime("%A, %d %B %Y", "fr"))

-- Returns a specific moment in time as a DateTime instance
local someDayInTheFuture = DateTime.fromLocalTime({
  year = 3033,
  month = 8,
  day = 26,
  hour = 16,
  minute = 56,
  second = 28,
  millisecond = 892,
})

-- Extracts the current local date & time as separate values (same values as above table)
print(now:toLocalTime())

-- Returns a DateTime instance from a given float, where the whole
-- denotes the seconds and the fraction denotes the milliseconds
-- Note that the fraction for millis here is completely optional
DateTime.fromUnixTimestamp(871978212313.321)

-- Extracts the current universal (UTC) date & time as separate values
print(now:toUniversalTime())

Properties
unixTimestamp
number

Number of seconds passed since the UNIX epoch.

unixTimestampMillis
number

Number of milliseconds passed since the UNIX epoch.

Constructors
now
Returns a DateTime representing the current moment in time.

Returns
DateTime The new DateTime object
fromUnixTimestamp
Creates a new DateTime from the given UNIX timestamp.

This timestamp may contain both a whole and fractional part - where the fractional part denotes milliseconds / nanoseconds.

Example usage of fractions:

DateTime.fromUnixTimestamp(123456789.001) - one millisecond
DateTime.fromUnixTimestamp(123456789.000000001) - one nanosecond
Note that the fractional part has limited precision down to exactly one nanosecond, any fraction that is more precise will get truncated.

Parameters
unixTimestamp number Seconds passed since the UNIX epoch
Returns
DateTime The new DateTime object
fromUniversalTime
Creates a new DateTime from the given date & time values table, in universal (UTC) time.

The given table must contain the following values:

Key	Type	Range
year	number	1400 -> 9999
month	number	1 -> 12
day	number	1 -> 31
hour	number	0 -> 23
minute	number	0 -> 59
second	number	0 -> 60
An additional millisecond value may also be included, and should be within the range 0 -> 999, but is optional.

Any non-integer values in the given table will be rounded down.

Errors
This constructor is fallible and may throw an error in the following situations:

Date units (year, month, day) were given that produce an invalid date. For example, January 32nd or February 29th on a non-leap year.
Parameters
values DateTimeValueArguments Table containing date & time values
Returns
DateTime The new DateTime object
fromLocalTime
Creates a new DateTime from the given date & time values table, in local time.

The given table must contain the following values:

Key	Type	Range
year	number	1400 -> 9999
month	number	1 -> 12
day	number	1 -> 31
hour	number	0 -> 23
minute	number	0 -> 59
second	number	0 -> 60
An additional millisecond value may also be included, and should be within the range 0 -> 999, but is optional.

Any non-integer values in the given table will be rounded down.

Errors
This constructor is fallible and may throw an error in the following situations:

Date units (year, month, day) were given that produce an invalid date. For example, January 32nd or February 29th on a non-leap year.
Parameters
values DateTimeValueArguments Table containing date & time values
Returns
DateTime The new DateTime object
fromIsoDate
DEPRECATED: Use DateTime.fromRfc3339 instead.

Creates a new DateTime from an ISO 8601 date-time string.

Errors
This constructor is fallible and may throw an error if the given string does not strictly follow the ISO 8601 date-time string format.

Some examples of valid ISO 8601 date-time strings are:

2020-02-22T18:12:08Z
2000-01-31T12:34:56+05:00
1970-01-01T00:00:00.055Z
Parameters
isoDate string An ISO 8601 formatted string
Returns
DateTime The new DateTime object
fromRfc3339
Creates a new DateTime from an RFC 3339 date-time string.

Errors
This constructor is fallible and may throw an error if the given string does not strictly follow the RFC 3339 date-time string format.

Some examples of valid RFC 3339 date-time strings are:

2020-02-22T18:12:08Z
2000-01-31T12:34:56+05:00
1970-01-01T00:00:00.055Z
Parameters
rfc3339Date string An RFC 3339 formatted string
Returns
DateTime The new DateTime object
fromRfc2822
Creates a new DateTime from an RFC 2822 date-time string.

Errors
This constructor is fallible and may throw an error if the given string does not strictly follow the RFC 2822 date-time string format.

Some examples of valid RFC 2822 date-time strings are:

Fri, 21 Nov 1997 09:55:06 -0600
Tue, 1 Jul 2003 10:52:37 +0200
Mon, 23 Dec 2024 01:58:48 GMT
Parameters
rfc2822Date string An RFC 2822 formatted string
Returns
DateTime The new DateTime object
Methods
formatLocalTime
Formats this DateTime using the given formatString and locale, as local time.

The given formatString is parsed using a strftime/strptime-inspired date and time formatting syntax, allowing tokens such as the following:

Token	Example	Description
%Y	1998	Year number
%m	04	Month number
%d	29	Day number
%A	Monday	Weekday name
%M	59	Minute number
%S	10	Second number
For a full reference of all available tokens, see the chrono documentation.

If not provided, formatString and locale will default to "%Y-%m-%d %H:%M:%S" and "en" (english) respectively.

Parameters
self DateTime

formatString string? A string containing formatting tokens

locale Locale? The locale the time should be formatted in

Returns
string The formatting string
formatUniversalTime
Formats this DateTime using the given formatString and locale, as UTC (universal) time.

The given formatString is parsed using a strftime/strptime-inspired date and time formatting syntax, allowing tokens such as the following:

Token	Example	Description
%Y	1998	Year number
%m	04	Month number
%d	29	Day number
%A	Monday	Weekday name
%M	59	Minute number
%S	10	Second number
For a full reference of all available tokens, see the chrono documentation.

If not provided, formatString and locale will default to "%Y-%m-%d %H:%M:%S" and "en" (english) respectively.

Parameters
self DateTime

formatString string? A string containing formatting tokens

locale Locale? The locale the time should be formatted in

Returns
string The formatting string
toIsoDate
DEPRECATED: Use DateTime.toRfc3339 instead.

Formats this DateTime as an ISO 8601 date-time string.

Some examples of ISO 8601 date-time strings are:

2020-02-22T18:12:08Z
2000-01-31T12:34:56+05:00
1970-01-01T00:00:00.055Z
Parameters
self DateTime
Returns
string The ISO 8601 formatted string
toRfc2822
Formats this DateTime as an RFC 2822 date-time string.

Some examples of RFC 2822 date-time strings are:

Fri, 21 Nov 1997 09:55:06 -0600
Tue, 1 Jul 2003 10:52:37 +0200
Mon, 23 Dec 2024 01:58:48 GMT
Parameters
self DateTime
Returns
string The RFC 2822 formatted string
toRfc3339
Formats this DateTime as an RFC 3339 date-time string.

Some examples of RFC 3339 date-time strings are:

2020-02-22T18:12:08Z
2000-01-31T12:34:56+05:00
1970-01-01T00:00:00.055Z
Parameters
self DateTime
Returns
string The RFC 3339 formatted string
toLocalTime
Extracts separated local date & time values from this DateTime.

The returned table contains the following values:

Key	Type	Range
year	number	1400 -> 9999
month	number	1 -> 12
day	number	1 -> 31
hour	number	0 -> 23
minute	number	0 -> 59
second	number	0 -> 60
millisecond	number	0 -> 999
Parameters
self DateTime
Returns
DateTimeValueReturns A table of DateTime values
toUniversalTime
Extracts separated UTC (universal) date & time values from this DateTime.

The returned table contains the following values:

Key	Type	Range
year	number	1400 -> 9999
month	number	1 -> 12
day	number	1 -> 31
hour	number	0 -> 23
minute	number	0 -> 59
second	number	0 -> 60
millisecond	number	0 -> 999
Parameters
self DateTime
Returns
DateTimeValueReturns A table of DateTime values
Types
Locale
Enum type representing supported DateTime locales.

Currently supported locales are:

en - English
de - German
es - Spanish
fr - French
it - Italian
ja - Japanese
pl - Polish
pt-br - Brazilian Portuguese
pt - Portuguese
tr - Turkish
DateTimeValues
Individual date & time values, representing the primitives that make up a DateTime.

This is a dictionary that will contain the following values:

year - Year(s), in the range 1400 -> 9999
month - Month(s), in the range 1 -> 12
day - Day(s), in the range 1 -> 31
hour - Hour(s), in the range 0 -> 23
minute - Minute(s), in the range 0 -> 59
second - Second(s), in the range 0 -> 60, where 60 is a leap second
An additional millisecond value may also be included, and should be within the range 0 -> 999, but is optional.

However, any method returning this type should be guaranteed to include milliseconds - see individual methods to verify.

DateTimeValueArguments
Alias for DateTimeValues with an optional millisecond value.

Refer to the DateTimeValues documentation for additional information.

DateTimeValueReturns
Alias for DateTimeValues with a mandatory millisecond value.

Refer to the DateTimeValues documentation for additional information.

FS
Built-in library for filesystem access

Example usage
local fs = require("@lune/fs")

-- Reading a file
local myTextFile: string = fs.readFile("myFileName.txt")

-- Reading entries (files & dirs) in a directory
for _, entryName in fs.readDir("myDirName") do
  if fs.isFile("myDirName/" .. entryName) then
    print("Found file " .. entryName)
  elseif fs.isDir("myDirName/" .. entryName) then
    print("Found subdirectory " .. entryName)
  end
end

Functions
readFile
Reads a file at path.

An error will be thrown in the following situations:

path does not point to an existing file.
The current process lacks permissions to read the file.
Some other I/O error occurred.
Parameters
path The path to the file to read
Returns
The contents of the file
readDir
Reads entries in a directory at path.

An error will be thrown in the following situations:

path does not point to an existing directory.
The current process lacks permissions to read the contents of the directory.
Some other I/O error occurred.
Parameters
path The directory path to search in
Returns
A list of files & directories found
writeFile
Writes to a file at path.

An error will be thrown in the following situations:

The file‚Äôs parent directory does not exist.
The current process lacks permissions to write to the file.
Some other I/O error occurred.
Parameters
path The path of the file

contents The contents of the file

writeDir
Creates a directory and its parent directories if they are missing.

An error will be thrown in the following situations:

path already points to an existing file or directory.
The current process lacks permissions to create the directory or its missing parents.
Some other I/O error occurred.
Parameters
path The directory to create
removeFile
Removes a file.

An error will be thrown in the following situations:

path does not point to an existing file.
The current process lacks permissions to remove the file.
Some other I/O error occurred.
Parameters
path The file to remove
removeDir
Removes a directory and all of its contents.

An error will be thrown in the following situations:

path is not an existing and empty directory.
The current process lacks permissions to remove the directory.
Some other I/O error occurred.
Parameters
path The directory to remove
metadata
Gets metadata for the given path.

An error will be thrown in the following situations:

The current process lacks permissions to read at path.
Some other I/O error occurred.
Parameters
path The path to get metadata for
Returns
Metadata for the path
isFile
Checks if a given path is a file.

An error will be thrown in the following situations:

The current process lacks permissions to read at path.
Some other I/O error occurred.
Parameters
path The file path to check
Returns
If the path is a file or not
isDir
Checks if a given path is a directory.

An error will be thrown in the following situations:

The current process lacks permissions to read at path.
Some other I/O error occurred.
Parameters
path The directory path to check
Returns
If the path is a directory or not
move
Moves a file or directory to a new path.

Throws an error if a file or directory already exists at the target path. This can be bypassed by passing true as the third argument, or a dictionary of options. Refer to the documentation for WriteOptions for specific option keys and their values.

An error will be thrown in the following situations:

The current process lacks permissions to read at from or write at to.
The new path exists on a different mount point.
Some other I/O error occurred.
Parameters
from The path to move from

to The path to move to

overwriteOrOptions Options for the target path, such as if should be overwritten if it already exists

copy
Copies a file or directory recursively to a new path.

Throws an error if a file or directory already exists at the target path. This can be bypassed by passing true as the third argument, or a dictionary of options. Refer to the documentation for WriteOptions for specific option keys and their values.

An error will be thrown in the following situations:

The current process lacks permissions to read at from or write at to.
Some other I/O error occurred.
Parameters
from The path to copy from

to The path to copy to

overwriteOrOptions Options for the target path, such as if should be overwritten if it already exists

Types
MetadataPermissions
Permissions for the given file or directory.

This is a dictionary that will contain the following values:

readOnly - If the target path is read-only or not
Metadata
Metadata for the given file or directory.

This is a dictionary that will contain the following values:

kind - If the target path is a file, dir or symlink
exists - If the target path exists
createdAt - The timestamp represented as a DateTime object at which the file or directory was created
modifiedAt - The timestamp represented as a DateTime object at which the file or directory was last modified
accessedAt - The timestamp represented as a DateTime object at which the file or directory was last accessed
permissions - Current permissions for the file or directory
Note that timestamps are relative to the unix epoch, and may not be accurate if the system clock is not accurate.

WriteOptions
Options for filesystem APIs what write to files and/or directories.

This is a dictionary that may contain one or more of the following values:

overwrite - If the target path should be overwritten or not, in the case that it already exists

Luau
Built-in library for generating luau bytecode & functions.

Example usage
local luau = require("@lune/luau")

local bytecode = luau.compile("print('Hello, World!')")
local callableFn = luau.load(bytecode)

-- Additionally, we can skip the bytecode generation and load a callable function directly from the code itself.
-- local callableFn = luau.load("print('Hello, World!')")

callableFn()

Since luau bytecode is highly compressible, it may also make sense to compress it using the serde library while transmitting large amounts of it.

Functions
compile
Compiles sourcecode into Luau bytecode

An error will be thrown if the sourcecode given isn‚Äôt valid Luau code.

Example usage
local luau = require("@lune/luau")

-- Compile the source to some highly optimized bytecode
local bytecode = luau.compile("print('Hello, World!')", {
  optimizationLevel = 2,
  coverageLevel = 0,
  debugLevel = 1,
})

Parameters
source The string that will be compiled into bytecode

compileOptions The options passed to the luau compiler that will output the bytecode

Returns
luau bytecode
load
Generates a function from either bytecode or sourcecode

An error will be thrown if the sourcecode given isn‚Äôt valid luau code.

Example usage
local luau = require("@lune/luau")

local bytecode = luau.compile("print('Hello, World!')")
local callableFn = luau.load(bytecode, {
  debugName = "'Hello, World'"
})

callableFn()

Parameters
source Either luau bytecode or string source code

loadOptions The options passed to luau for loading the chunk

Returns
luau chunk
Types
CompileOptions
The options passed to the luau compiler while compiling bytecode.

This is a dictionary that may contain one or more of the following values:

optimizationLevel - Sets the compiler option ‚ÄúoptimizationLevel‚Äù. Defaults to 1.
coverageLevel - Sets the compiler option ‚ÄúcoverageLevel‚Äù. Defaults to 0.
debugLevel - Sets the compiler option ‚ÄúdebugLevel‚Äù. Defaults to 1.
Documentation regarding what these values represent can be found here.

LoadOptions
The options passed while loading a luau chunk from an arbitrary string, or bytecode.

This is a dictionary that may contain one or more of the following values:

debugName - The debug name of the closure. Defaults to luau.load(...).
environment - A custom environment to load the chunk in. Setting a custom environment will deoptimize the chunk and forcefully disable codegen. Defaults to the global environment.
injectGlobals - Whether or not to inject globals in the custom environment. Has no effect if no custom environment is provided. Defaults to true.
codegenEnabled - Whether or not to enable codegen. Defaults to false.

Net
Built-in library for network access

Example usage
local net = require("@lune/net")
local serde = require("@lune/serde")

-- Sending a web request
local response = net.request("https://www.google.com")
print(response.ok)
print(response.statusCode, response.statusMessage)
print(response.headers)

-- Using a JSON web API
local response = net.request({
  url = "https://dummyjson.com/products/add",
  method = "POST",
  headers = { ["Content-Type"] = "application/json" },
  body = serde.encode("json", {
    title = "Cool Pencil",
  })
})
local product = serde.decode("json", response.body)
print(product.id, "-", product.title)

-- Starting up an http server
net.serve(8080, function(request)
  return {
    status = 200,
    body = "Echo:\n" .. request.body,
  }
end)

-- Writing to a plain TCP stream
local conn = net.tcp.connect("example.com", 80)

conn:write("GET / HTTP/1.1\r\nHost: example.com\r\n\r\n")

Functions
request
Sends an HTTP request using the given url and / or parameters, and returns a dictionary that describes the response received.

Only throws an error if a miscellaneous network or I/O error occurs, never for unsuccessful status codes.

Parameters
config The URL or request config to use
Returns
A dictionary representing the response for the request
socket
Connects to a web socket at the given URL.

Throws an error if the server at the given URL does not support web sockets, or if a miscellaneous network or I/O error occurs.

Parameters
url The URL to connect to
Returns
A web socket handle
serve
Creates an HTTP server that listens on the given port.

This will not block and will keep listening for requests on the given port until the stop function on the returned ServeHandle has been called.

Parameters
port The port to use for the server

handlerOrConfig The handler function or config to use for the server

Returns
ServeHandle
urlEncode
Encodes the given string using URL encoding.

Parameters
s The string to encode

binary If the string should be treated as binary data and/or is not valid utf-8. Defaults to false

Returns
The encoded string
urlDecode
Decodes the given string using URL decoding.

Parameters
s The string to decode

binary If the string should be treated as binary data and/or is not valid utf-8. Defaults to false

Returns
The decoded string
Types
FetchParamsOptions
Extra options for FetchParams.

This is a dictionary that may contain one or more of the following values:

decompress - If the request body should be automatically decompressed when possible. Defaults to true
FetchParams
Parameters for sending network requests with net.request.

This is a dictionary that may contain one or more of the following values:

url - The URL to send a request to. This is always required
method - The HTTP method verb, such as "GET", "POST", "PATCH", "PUT", or "DELETE". Defaults to "GET"
body - The request body
query - A table of key-value pairs representing query parameters in the request path
headers - A table of key-value pairs representing headers
options - Extra options for things such as automatic decompression of response bodies
FetchResponse
Response type for sending network requests with net.request.

This is a dictionary containing the following values:

ok - If the status code is a canonical success status code, meaning within the range 200 -> 299
statusCode - The status code returned for the request
statusMessage - The canonical status message for the returned status code, such as "Not Found" for status code 404
headers - A table of key-value pairs representing headers
body - The request body, or an empty string if one was not given
ServeRequest
Data type for requests in net.serve.

This is a dictionary containing the following values:

path - The path being requested, relative to the root. Will be / if not specified
query - A table of key-value pairs representing query parameters in the request path
method - The HTTP method verb, such as "GET", "POST", "PATCH", "PUT", or "DELETE". Will always be uppercase
headers - A table of key-value pairs representing headers
body - The request body, or an empty string if one was not given
ServeResponse
Response type for requests in net.serve.

This is a dictionary that may contain one or more of the following values:

status - The status code for the request, in the range 100 -> 599
headers - A table of key-value pairs representing headers
body - The response body
ServeConfig
Configuration for net.serve.

This may contain one of or more of the following values:

address for setting the IP address to serve from. Defaults to the loopback interface (http://localhost).
handleRequest for handling normal http requests, equivalent to just passing a function to net.serve
handleWebSocket for handling web socket requests, which will receive a WebSocket object as its first and only parameter
When setting address, the handleRequest callback must also be defined.

Example Usage
net.serve(8080, {
  address = "http://0.0.0.0",
  handleRequest = function(request)
    return {
      status = 200,
      body = "Echo:\n" .. request.body,
    }
  end
})

ServeHandle
A handle to a currently running web server, containing a single stop function to gracefully shut down the web server.

WebSocket
A reference to a web socket connection.

The web socket may be in either an ‚Äúopen‚Äù or a ‚Äúclosed‚Äù state, changing its current behavior.

When open:

Any function on the socket such as send, next or close can be called without erroring
next can be called to yield until the next message is received or the socket becomes closed
When closed:

next will no longer return any message(s) and instead instantly return nil
send will throw an error stating that the socket has been closed
Once the websocket has been closed, closeCode will no longer be nil, and will be populated with a close code according to the WebSocket specification. This will be an integer between 1000 and 4999, where 1000 is the canonical code for normal, error-free closure.

TcpConfig
Configuration options for a TCP stream.

Example Usage
-- Plain TCP connection
local stream = net.tcp.connect("example.com", 80)

-- TLS connection (shorthand)
local stream = net.tcp.connect("example.com", 443, true)

-- TLS connection (explicit config)
local stream = net.tcp.connect("example.com", 443, { tls = true })

-- Connection with custom TTL
local stream = net.tcp.connect("192.168.1.100", 8080, {
  tls = false,
  ttl = 128
})

TcpStream
A plain TCP stream, which may also be backed by a TLS connection.

Example Usage
local net = require("@lune/net")

local conn = net.tcp.connect("example.com", 80)

conn:write("GET / HTTP/1.1\r\nHost: example.com\r\n\r\n")

local response = conn:read()
print(response)

conn:close()

Tcp
TCP primitives for the net library

Provides low-level TCP socket functionality for creating custom network protocols or communicating with services that don‚Äôt use HTTP - for all HTTP usage, please use the request and serve HTTP functions instead.

Functions
connect
Connects to the given host and port, returning a TcpStream.

For additional details, see the documentation for the TcpConfig and TcpStream types.

Will throw an error if the connection fails.

Parameters
host The host to connect to, either a DNS name or IP address

port The port to connect to

config The optional configuration to use for the stream

Returns
A connected TcpStream ready for reading and writing

Process
Built-in functions for the current process & child processes

Example usage
local process = require("@lune/process")

-- Getting the arguments passed to the Lune script
for index, arg in process.args do
  print("Process argument #" .. tostring(index) .. ": " .. arg)
end

-- Getting the currently available environment variables
local PORT: string? = process.env.PORT
local HOME: string? = process.env.HOME
for name, value in process.env do
  print("Environment variable " .. name .. " is set to " .. value)
end

-- Getting the current os and processor architecture
print("Running " .. process.os .. " on " .. process.arch .. "!")

-- Executing a command
local result = process.exec("program", {
  "cli argument",
  "other cli argument"
})
if result.ok then
  print(result.stdout)
else
  print(result.stderr)
end

-- Spawning a child process
local child = process.create("program", {
  "cli argument",
  "other cli argument"
})

-- Writing to the child process' stdin
child.stdin:write("Hello from Lune!")

-- Reading from the child process' stdout
local data = child.stdout:read()
print(data)

Properties
os
OS

The current operating system being used.

Possible values:

"linux"
"macos"
"windows"
arch
Arch

The architecture of the processor currently being used.

Possible values:

"x86_64"
"aarch64"
endianness
Endianness

The endianness of the processor currently being used.

Possible values:

"big"
"little"
args
{ string }

The arguments given when running the Lune script.

cwd
string

The current working directory in which the Lune script is running.

env
{ [string]: string? }

Current environment variables for this process.

Setting a value on this table will set the corresponding environment variable.

Functions
exit
Exits the currently running script as soon as possible with the given exit code.

Exit code 0 is treated as a successful exit, any other value is treated as an error.

Setting the exit code using this function will override any otherwise automatic exit code.

Parameters
code The exit code to set
Returns
never
create
Spawns a child process in the background that runs the program program, and immediately returns readers and writers to communicate with it.

In order to execute a command and wait for its output, see process.exec.

The second argument, params, can be passed as a list of string parameters to give to the program.

The third argument, options, can be passed as a dictionary of options to give to the child process. Refer to the documentation for SpawnOptions for specific option keys and their values.

Parameters
program The program to Execute as a child process

params Additional parameters to pass to the program

options A dictionary of options for the child process

Returns
A dictionary with the readers and writers to communicate with the child process
exec
Executes a child process that will execute the command program, waiting for it to exit. Upon exit, it returns a dictionary that describes the final status and output of the child process.

In order to spawn a child process in the background, see process.create.

The second argument, params, can be passed as a list of string parameters to give to the program.

The third argument, options, can be passed as a dictionary of options to give to the child process. Refer to the documentation for ExecOptions for specific option keys and their values.

Parameters
program The program to Execute as a child process

params Additional parameters to pass to the program

options A dictionary of options for the child process

Returns
A dictionary representing the result of the child process
Types
ExecStdioKind
Enum determining how to treat a standard input/output stream for process.exec.

Can be one of the following values:

default - The default behavior, writing to the final result table only
inherit - Inherit the stream from the parent process, writing to both the result table and the respective stream for the parent process
forward - Forward the stream to the parent process, without writing to the result table, only respective stream for the parent process
none - Do not create any input/output stream
ExecStdioOptions
A dictionary of stdio-specific options for process.exec, with the following available values:

stdin - A buffer or string to write to the stdin of the process
stdout - How to treat the stdout stream from the child process - see ExecStdioKind for more info
stderr - How to treat the stderr stream from the child process - see ExecStdioKind for more info
ExecOptions
A dictionary of options for process.exec, with the following available values:

cwd - The current working directory for the process
env - Extra environment variables to give to the process
shell - Whether to run in a shell or not - set to true to run using the default shell, or a string to run using a specific shell
stdio - How to treat output and error streams from the child process - see StdioKind and StdioOptions for more info
CreateOptions
A dictionary of options for process.create, with the following available values:

cwd - The current working directory for the process
env - Extra environment variables to give to the process
shell - Whether to run in a shell or not - set to true to run using the default shell, or a string to run using a specific shell
ChildProcess
Result type for child processes in process.create.

This is a dictionary containing the following values:

stdin - A writer to write to the child process‚Äô stdin - see ChildProcessWriter for more info
stdout - A reader to read from the child process‚Äô stdout - see ChildProcessReader for more info
stderr - A reader to read from the child process‚Äô stderr - see ChildProcessReader for more info
kill - A method that kills the child process
status - A method that yields and returns the exit status of the child process
ExecResult
Result type for child processes in process.exec.

This is a dictionary containing the following values:

ok - If the child process exited successfully or not, meaning the exit code was zero or not set
code - The exit code set by the child process, or 0 if one was not set
stdout - The full contents written to stdout by the child process, or an empty string if nothing was written
stderr - The full contents written to stderr by the child process, or an empty string if nothing was written
ChildProcessReader
A reader class to read data from a child process‚Äô streams in realtime.

Functions
read
Reads a chunk of data up to the specified length, or a default of 1KB at a time.

Returns nil if there is no more data to read.

This function may yield until there is new data to read from reader, if all data till present has already been read, and the process has not exited.

Parameters
chunkSize number?
Returns
The string containing the data read from the reader
readToEnd
Reads all the data currently present in the reader as a string. This function will yield until the process exits.

Returns
The string containing the data read from the reader
ChildProcessWriter
A writer class to write data to a child process‚Äô streams in realtime.

Functions
write
Writes a buffer or string of data to the writer.

Parameters
data The data to write to the writer
close
Closes the underlying I/O stream for the writer.

Regex
Built-in library for regular expressions

Example usage
local Regex = require("@lune/regex")

local re = Regex.new("hello")

if re:isMatch("hello, world!") then
  print("Matched!")
end

local caps = re:captures("hello, world! hello, again!")

print(#caps) -- 2
print(caps:get(1)) -- "hello"
print(caps:get(2)) -- "hello"
print(caps:get(3)) -- nil

Constructors
new
Creates a new Regex from a given string pattern.

Errors
This constructor throws an error if the given pattern is invalid.

Parameters
pattern string The string pattern to use
Returns
Regex The new Regex object
Methods
isMatch
Check if the given text matches the regular expression.

This method may be slightly more efficient than calling find if you only need to know if the text matches the pattern.

Parameters
self Regex

text string The text to search

Returns
boolean Whether the text matches the pattern
find
Finds the first match in the given text.

Returns nil if no match was found.

Parameters
self Regex

text string The text to search

Returns
RegexMatch? The match object
captures
Finds all matches in the given text as a RegexCaptures object.

Returns nil if no matches are found.

Parameters
self Regex

text string The text to search

Returns
RegexCaptures? The captures object
split
Splits the given text using the regular expression.

Parameters
self Regex

text string The text to split

Returns
{ string } The split text
replace
Replaces the first match in the given text with the given replacer string.

Parameters
self Regex

haystack string The text to search

replacer string The string to replace matches with

Returns
string The text with the first match replaced
replaceAll
Replaces all matches in the given text with the given replacer string.

Parameters
self Regex

haystack string The text to search

replacer string The string to replace matches with

Returns
string The text with all matches replaced
RegexMatch
A match from a regular expression.

Contains the following values:

start ‚Äî The start index of the match in the original string.
finish ‚Äî The end index of the match in the original string.
text ‚Äî The text that was matched.
len ‚Äî The length of the text that was matched.
RegexCaptures
Captures from a regular expression.

Roblox
Built-in library for manipulating Roblox place & model files

Example usage
local fs = require("@lune/fs")
local roblox = require("@lune/roblox")

-- Reading a place file
local placeFile = fs.readFile("myPlaceFile.rbxl")
local game = roblox.deserializePlace(placeFile)

-- Manipulating and reading instances - just like in Roblox!
local workspace = game:GetService("Workspace")
for _, child in workspace:GetChildren() do
  print("Found child " .. child.Name .. " of class " .. child.ClassName)
end

-- Writing a place file
local newPlaceFile = roblox.serializePlace(game)
fs.writeFile("myPlaceFile.rbxl", newPlaceFile)

Functions
deserializePlace
Deserializes a place into a DataModel instance.

This function accepts a string of contents, not a file path. If reading a place file from a file path is desired, fs.readFile can be used and the resulting string may be passed to this function.

Example usage
local fs = require("@lune/fs")
local roblox = require("@lune/roblox")

local placeFile = fs.readFile("filePath.rbxl")
local game = roblox.deserializePlace(placeFile)

Parameters
contents The contents of the place to read
Returns
DataModel
deserializeModel
Deserializes a model into an array of instances.

This function accepts a string of contents, not a file path. If reading a model file from a file path is desired, fs.readFile can be used and the resulting string may be passed to this function.

Example usage
local fs = require("@lune/fs")
local roblox = require("@lune/roblox")

local modelFile = fs.readFile("filePath.rbxm")
local instances = roblox.deserializeModel(modelFile)

Parameters
contents The contents of the model to read
Returns
{ Instance }
serializePlace
Serializes a place from a DataModel instance.

This string can then be written to a file, or sent over the network.

Example usage
local fs = require("@lune/fs")
local roblox = require("@lune/roblox")

local placeFile = roblox.serializePlace(game)
fs.writeFile("filePath.rbxl", placeFile)

Parameters
dataModel The DataModel for the place to serialize

xml If the place should be serialized as xml or not. Defaults to false, meaning the place gets serialized using the binary format and not xml.

Returns
string
serializeModel
Serializes one or more instances as a model.

This string can then be written to a file, or sent over the network.

Example usage
local fs = require("@lune/fs")
local roblox = require("@lune/roblox")

local modelFile = roblox.serializeModel({ instance1, instance2, ... })
fs.writeFile("filePath.rbxm", modelFile)

Parameters
instances The array of instances to serialize

xml If the model should be serialized as xml or not. Defaults to false, meaning the model gets serialized using the binary format and not xml.

Returns
string
getAuthCookie
Gets the current auth cookie, for usage with Roblox web APIs.

Note that this auth cookie is formatted for use as a ‚ÄúCookie‚Äù header, and that it contains restrictions so that it may only be used for official Roblox endpoints. To get the raw cookie value without any additional formatting, you can pass true as the first and only parameter.

Example usage
local roblox = require("@lune/roblox")
local serde = require("@lune/serde")
local net = require("@lune/net")

local cookie = roblox.getAuthCookie()
assert(cookie ~= nil, "Failed to get roblox auth cookie")

local myPrivatePlaceId = 1234567890

local response = net.request({
  url = "https://assetdelivery.roblox.com/v2/assetId/" .. tostring(myPrivatePlaceId),
  headers = {
    Cookie = cookie,
  },
})

local responseTable = serde.decode("json", response.body)
local responseLocation = responseTable.locations[1].location
print("Download link to place: " .. responseLocation)

Parameters
raw If the cookie should be returned as a pure value or not. Defaults to false
Returns
string?
getReflectionDatabase
Gets the bundled reflection database.

This database contains information about Roblox enums, classes, and their properties.

Example usage
local roblox = require("@lune/roblox")

local db = roblox.getReflectionDatabase()

print("There are", #db:GetClassNames(), "classes in the reflection database")

print("All base instance properties:")

local class = db:GetClass("Instance")
for name, prop in class.Properties do
  print(string.format(
    "- %s with datatype %s and default value %s",
    prop.Name,
    prop.Datatype,
    tostring(class.DefaultProperties[prop.Name])
  ))
end

Returns
Database
implementProperty
Implements a property for all instances of the given className.

This takes into account class hierarchies, so implementing a property for the BasePart class will also implement it for Part and others, unless a more specific implementation is added to the Part class directly.

Behavior
The given getter callback will be called each time the property is indexed, with the instance as its one and only argument. The setter callback, if given, will be called each time the property should be set, with the instance as the first argument and the property value as second.

Example usage
local roblox = require("@lune/roblox")

local part = roblox.Instance.new("Part")

local propertyValues = {}
roblox.implementProperty(
  "BasePart",
  "CoolProp",
  function(instance)
    if propertyValues[instance] == nil then
      propertyValues[instance] = 0
    end
    propertyValues[instance] += 1
    return propertyValues[instance]
  end,
  function(instance, value)
    propertyValues[instance] = value
  end
)

print(part.CoolProp) --> 1
print(part.CoolProp) --> 2
print(part.CoolProp) --> 3

part.CoolProp = 10

print(part.CoolProp) --> 11
print(part.CoolProp) --> 12
print(part.CoolProp) --> 13

Parameters
className The class to implement the property for.

propertyName The name of the property to implement.

getter The function which will be called to get the property value when indexed.

setter The function which will be called to set the property value when indexed. Defaults to a function that will error with a message saying the property is read-only.

implementMethod
Implements a method for all instances of the given className.

This takes into account class hierarchies, so implementing a method for the BasePart class will also implement it for Part and others, unless a more specific implementation is added to the Part class directly.

Behavior
The given callback will be called every time the method is called, and will receive the instance it was called on as its first argument. The remaining arguments will be what the caller passed to the method, and all values returned from the callback will then be returned to the caller.

Example usage
local roblox = require("@lune/roblox")

local part = roblox.Instance.new("Part")

roblox.implementMethod("BasePart", "TestMethod", function(instance, ...)
    print("Called TestMethod on instance", instance, "with", ...)
end)

part:TestMethod("Hello", "world!")
--> Called TestMethod on instance Part with Hello, world!

Parameters
className The class to implement the method for.

methodName The name of the method to implement.

callback The function which will be called when the method is called.

studioApplicationPath
Returns the path to the system‚Äôs Roblox Studio executable.

There is no guarantee that this will exist, but if Studio is installed this is where it will be.

Example usage
local roblox = require("@lune/roblox")

local pathToStudio = roblox.studioApplicationPath()
print("Studio is located at:", pathToStudio)

Returns
string
studioContentPath
Returns the path to the Content folder of the system‚Äôs current Studio install.

This folder will always exist if Studio is installed.

Example usage
local roblox = require("@lune/roblox")

local pathToContent = roblox.studioContentPath()
print("Studio's content folder is located at:", pathToContent)

Returns
string
studioPluginPath
Returns the path to the plugin folder of the system‚Äôs current Studio install. This is the path where local plugins are installed.

This folder may not exist if the user has never installed a local plugin. It will also not necessarily take into account custom plugin directories set from Studio.

Example usage
local roblox = require("@lune/roblox")

local pathToPluginFolder = roblox.studioPluginPath()
print("Studio's plugin folder is located at:", pathToPluginFolder)

Returns
string
studioBuiltinPluginPath
Returns the path to the BuiltInPlugin folder of the system‚Äôs current Studio install. This is the path where built-in plugins like the ToolBox are installed.

This folder will always exist if Studio is installed.

Example usage
local roblox = require("@lune/roblox")

local pathToPluginFolder = roblox.studioBuiltinPluginPath()
print("Studio's built-in plugin folder is located at:", pathToPluginFolder)

Returns
string

Serde
Built-in library for:

serialization & deserialization
encoding & decoding
compression
Example usage
local fs = require("@lune/fs")
local serde = require("@lune/serde")

-- Parse different file formats into lua tables
local someJson = serde.decode("json", fs.readFile("myFile.json"))
local someToml = serde.decode("toml", fs.readFile("myFile.toml"))
local someYaml = serde.decode("yaml", fs.readFile("myFile.yaml"))

-- Write lua tables to files in different formats
fs.writeFile("myFile.json", serde.encode("json", someJson))
fs.writeFile("myFile.toml", serde.encode("toml", someToml))
fs.writeFile("myFile.yaml", serde.encode("yaml", someYaml))

Functions
encode
Encodes the given value using the given format.

See [EncodeDecodeFormat] for a list of supported formats.

Parameters
format The format to use

value The value to encode

pretty If the encoded string should be human-readable, including things such as newlines and spaces. Only supported for json and toml formats, and defaults to false

Returns
The encoded string
decode
Decodes the given string using the given format into a lua value.

See [EncodeDecodeFormat] for a list of supported formats.

Parameters
format The format to use

encoded The string to decode

Returns
The decoded lua value
compress
Compresses the given string using the given format.

See [CompressDecompressFormat] for a list of supported formats.

Parameters
format The format to use

s The string to compress

level The compression level to use, clamped to the format‚Äôs limits. The best compression level is used by default

Returns
The compressed string
decompress
Decompresses the given string using the given format.

See [CompressDecompressFormat] for a list of supported formats.

Parameters
format The format to use

s The string to decompress

Returns
The decompressed string
hash
Hashes the given message using the given algorithm and returns the hash as a hex string.

See [HashAlgorithm] for a list of supported algorithms.

Parameters
algorithm The algorithm to use

message The message to hash

Returns
The hash as a hex string
hmac
Hashes the given message using HMAC with the given secret and algorithm, returning the hash as a base64 string.

See [HashAlgorithm] for a list of supported algorithms.

Parameters
algorithm The algorithm to use

message The message to hash

secret string | buffer

Returns
The hash as a base64 string
Types
EncodeDecodeFormat
A serialization/deserialization format supported by the Serde library.

Currently supported formats:

Name	Learn More
json	https://www.json.org
yaml	https://yaml.org
toml	https://toml.io
CompressDecompressFormat
A compression/decompression format supported by the Serde library.

Currently supported formats:

Name	Learn More
brotli	https://github.com/google/brotli
gzip	https://www.gnu.org/software/gzip
lz4	https://github.com/lz4/lz4
zlib	https://www.zlib.net
zstd	https://github.com/facebook/zstd
HashAlgorithm
A hash algorithm supported by the Serde library.

Currently supported algorithms:

Name	Learn More
md5	https://en.wikipedia.org/wiki/MD5
sha1	https://en.wikipedia.org/wiki/SHA-1
sha224	https://en.wikipedia.org/wiki/SHA-2
sha256	https://en.wikipedia.org/wiki/SHA-2
sha384	https://en.wikipedia.org/wiki/SHA-2
sha512	https://en.wikipedia.org/wiki/SHA-2
sha3-224	https://en.wikipedia.org/wiki/SHA-3
sha3-256	https://en.wikipedia.org/wiki/SHA-3
sha3-384	https://en.wikipedia.org/wiki/SHA-3
sha3-512	https://en.wikipedia.org/wiki/SHA-3
blake3	https://en.wikipedia.org/wiki/BLAKE3

Stdio
Built-in standard input / output & utility functions

Example usage
local stdio = require("@lune/stdio")

-- Prompting the user for basic input
local text: string = stdio.prompt("text", "Please write some text")
local confirmed: boolean = stdio.prompt("confirm", "Please confirm this action")

-- Writing directly to stdout or stderr, without the auto-formatting of print/warn/error
stdio.write("Hello, ")
stdio.write("World! ")
stdio.write("All on the same line")
stdio.ewrite("\nAnd some error text, too")

-- Reading a single line from stdin
local line = stdio.readLine()

-- Reading the entire input from stdin
local input = stdio.readToEnd()

Functions
prompt
Prompts for user input using the wanted kind of prompt:

"text" - Prompts for a plain text string from the user
"confirm" - Prompts the user to confirm with y / n (yes / no)
"select" - Prompts the user to select one value from a list
"multiselect" - Prompts the user to select one or more values from a list
nil - Equivalent to "text" with no extra arguments
Parameters
kind The kind of prompt to use

message The message to show the user

defaultOrOptions The default value for the prompt, or options to choose from for selection prompts

color
Return an ANSI string that can be used to modify the persistent output color.

Pass "reset" to get a string that can reset the persistent output color.

Example usage
stdio.write(stdio.color("red"))
print("This text will be red")
stdio.write(stdio.color("reset"))
print("This text will be normal")

Parameters
color The color to use
Returns
A printable ANSI string
style
Return an ANSI string that can be used to modify the persistent output style.

Pass "reset" to get a string that can reset the persistent output style.

Example usage
stdio.write(stdio.style("bold"))
print("This text will be bold")
stdio.write(stdio.style("reset"))
print("This text will be normal")

Parameters
style The style to use
Returns
A printable ANSI string
format
Formats arguments into a human-readable string with syntax highlighting for tables.

Parameters
... The values to format
Returns
The formatted string
write
Writes a string directly to stdout, without any newline.

Parameters
s The string to write to stdout
ewrite
Writes a string directly to stderr, without any newline.

Parameters
s The string to write to stderr
readLine
Reads a single line from stdin.

If stdin is closed, returns all input up until its closure.

Returns
The input from stdin
readToEnd
Reads the entire input from stdin.

Returns
The input from stdin

Task
Built-in task scheduler & thread spawning

Example usage
local task = require("@lune/task")

-- Waiting for a certain amount of time
task.wait(1)
print("Waited for one second")

-- Running a task after a given amount of time
task.delay(2, function()
  print("Ran after two seconds")
end)

-- Spawning a new task that runs concurrently
task.spawn(function()
  print("Running instantly")
  task.wait(1)
  print("One second passed inside the task")
end)

print("Running after task.spawn yields")

Functions
cancel
Stops a currently scheduled thread from resuming.

Parameters
thread The thread to cancel
defer
Defers a thread or function to run at the end of the current task queue.

Parameters
functionOrThread The function or thread to defer

... T‚Ä¶

Returns
The thread that will be deferred
delay
Delays a thread or function to run after duration seconds.

Parameters
duration number

functionOrThread The function or thread to delay

... T‚Ä¶

Returns
The thread that will be delayed
spawn
Instantly runs a thread or function.

If the spawned task yields, the thread that spawned the task will resume, letting the spawned task run in the background.

Parameters
functionOrThread The function or thread to spawn

... T‚Ä¶

Returns
The thread that was spawned
wait
Waits for at least the given amount of time.

The minimum wait time possible when using task.wait is limited by the underlying OS sleep implementation. For most systems this means task.wait is accurate down to about 5 milliseconds or less.

Parameters
duration The amount of time to wait
Returns
The exact amount of time waited